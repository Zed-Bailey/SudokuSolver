@page "/solve"
@using SudokuSolver.UI.Data
@inject GridService _service
@inject NavigationManager _navigation
<style>
    td {
        width: 50px ;
        height: 50px ;
        text-align: center;
    }
    
    tr:nth-of-type(3) td {
         border-bottom: 3px solid red !important;
    }
    
    tr:nth-of-type(6) td {
         border-bottom: 3px solid red !important;
    }
    
    
    td:nth-of-type(3) {
         border-right: 3px solid red !important;
    }
    td:nth-of-type(6) {
         border-right: 3px solid red !important;
    }
    
    td > input {
        width: 50px;
        height: 50px; 
        text-align: center;
    }
    .entered {
        background-color: darkseagreen;
    }
    
    .negativeOne {
        background-color: #ece1be;
    }
</style>
@if (_solved)
{
    <h3>Solved on iteration: @_iteration</h3>    
}
else
{
    <h3>Solve iteration: @_iteration</h3>
}


<table >
    <tbody>
    @for (var r = 0; r < Sudoku.Height; r++)
    {
        
        <tr>
            @for (var c = 0; c < Sudoku.Width; c++)
            {
                
                var value = _sudoku.CurrentBoard[r, c].Value;
                var style = value == -1 ? "negativeOne" : "entered";
    
                <td class="@style">@(value == -1 ? "" : value)</td>
            }
        </tr>
    }
    
     @* @for (var r = 0; r < Sudoku.Height; r++) *@
     @*    { *@
     @*        <tr>  *@
     @*            <td onchange="this.value = this.value == -1 ? '' : this.value">@_sudoku.CurrentBoard[r, 0].Value</td> *@
     @*            <td onchange="this.value = this.value == -1 ? '' : this.value">@_sudoku.CurrentBoard[r, 1].Value</td> *@
     @*            <td>@_sudoku.CurrentBoard[r, 2].Value</td> *@
     @*            <td>@_sudoku.CurrentBoard[r, 3].Value</td> *@
     @*            <td>@_sudoku.CurrentBoard[r, 4].Value</td> *@
     @*            <td>@_sudoku.CurrentBoard[r, 5].Value</td> *@
     @*            <td>@_sudoku.CurrentBoard[r, 6].Value</td> *@
     @*            <td>@_sudoku.CurrentBoard[r, 7].Value</td> *@
     @*            <td>@_sudoku.CurrentBoard[r, 8].Value</td> *@
     @*        </tr>  *@
     @*    } *@
    </tbody>
</table>

<div class="mt-4">
    @if (_solving)
    {
        <button class="btn btn-danger" @onclick="() => _solving = false">Stop Solving</button>
    }
    else
    {
        <button class="btn btn-primary" @onclick="Start">Start Solving</button>
    }
    
    <button class="btn btn-secondary" @onclick="GoHome">Reset Board</button>
</div>

<div class="mt-3" style="width: 500px;">
    <label for="delayRange" class="form-label">@_delay millisecond delay between updates</label>
    <input type="range" class="form-range" min="0" max="1000" id="delayRange" @bind="@_delay" @bind:event="oninput"/>
</div>



@code {
    Sudoku _sudoku;
    int _iteration;
    int _delay = 500;
    bool _solved;
    bool _solving;
    
    protected override void OnInitialized()
    {
        // if the sudoku instance is null return back to index where user can create a board
        if (_service.SudokuGrid == null)
        {
            _navigation.NavigateTo("/");
            return;
        }
        
        _sudoku = _service.SudokuGrid;
    }

    void GoHome() => _navigation.NavigateTo("/");
    
    async void Start()
    {
        _solving = true;
        
        for (var i = 0; i < 10_000; i++)
        {
            _iteration = i;
            _sudoku.Solve();
            StateHasChanged();
            
            // if solving is false
            if(!_solving) break;
            
            
            await Task.Delay(_delay);
            if (!_sudoku.ValidSolve())
            {
                _sudoku.Reset();
                StateHasChanged();
                await Task.Delay(_delay);
            }
            else
            {
                _solved = true;
                break;
            }
            
        }
        StateHasChanged();
    }

} 